# Web Designer Project - AI Assistant Rules

## Project Overview
This is a Next.js 15 project with TypeScript, Tailwind CSS, and modern React patterns. The project uses pnpm as the package manager and follows best practices for modern web development.

## Technology Stack
- **Framework**: Next.js 15 with App Router
- **Language**: TypeScript
- **Styling**: Tailwind CSS v4
- **Package Manager**: pnpm
- **Linting**: ESLint with Next.js config
- **Runtime**: React 19

## Code Style and Conventions

### General Guidelines
- Use TypeScript for all code
- Prefer functional components over class components
- Use React hooks for state management
- Follow Next.js App Router conventions
- Use modern ES6+ syntax
- Prefer const over let when variables won't be reassigned

### File Structure
- Place components in `src/components/`
- Use descriptive folder names and file names
- Group related components in subdirectories
- Keep utilities in `src/lib/` or `src/utils/`
- Place custom hooks in `src/hooks/`
- Store types in `src/types/` or co-locate with components

### Component Guidelines
- Use PascalCase for component names
- Export components as default when there's only one export
- Use named exports for utilities and hooks
- Include proper TypeScript interfaces for props
- Use React.FC type annotation for components when needed

### Styling Guidelines
- Use Tailwind CSS classes for styling
- Prefer utility classes over custom CSS when possible
- Use Tailwind's design system (spacing, colors, etc.)
- Create custom components for reusable UI patterns
- Use CSS modules or styled-components only when Tailwind is insufficient

### State Management
- Use React hooks (useState, useEffect, useContext) for local state
- Consider Zustand or React Query for complex state management
- Use React Context sparingly, prefer prop drilling for simple cases
- Implement proper loading and error states

### Performance Considerations
- Use Next.js Image component for images
- Implement proper code splitting
- Use React.memo for expensive components
- Prefer server components when possible in App Router
- Use dynamic imports for large components

### Error Handling
- Implement proper error boundaries
- Use try-catch blocks for async operations
- Provide meaningful error messages to users
- Log errors appropriately for debugging

### Accessibility
- Use semantic HTML elements
- Include proper ARIA labels and roles
- Ensure keyboard navigation works
- Maintain proper color contrast ratios
- Test with screen readers

## Specific Instructions

### When creating components:
1. Always include TypeScript interfaces for props
2. Use proper semantic HTML
3. Implement responsive design with Tailwind
4. Add proper error handling
5. Include loading states when applicable

### When working with APIs:
1. Use Next.js API routes or server actions
2. Implement proper error handling
3. Use TypeScript for request/response types
4. Consider data validation with libraries like Zod

### When adding dependencies:
1. Check if the functionality can be achieved with built-in features first
2. Prefer well-maintained, popular packages
3. Use pnpm for package management
4. Update package.json scripts when needed

### Code Quality
- Write self-documenting code with clear variable and function names
- Add comments for complex business logic
- Use ESLint rules and fix all warnings
- Follow the existing code style in the project
- Write unit tests for critical functionality

## Common Patterns to Follow

### Server Components (default in App Router)
```typescript
// Use for static content, SEO, and server-side data fetching
export default async function ServerComponent() {
  const data = await fetchData();
  return <div>{data.title}</div>;
}
```

### Client Components
```typescript
'use client';
// Use for interactivity, hooks, and browser APIs
import { useState } from 'react';

export default function ClientComponent() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

### Custom Hooks
```typescript
import { useState, useEffect } from 'react';

export function useCustomHook() {
  const [state, setState] = useState(initialState);
  
  useEffect(() => {
    // Effect logic
  }, []);
  
  return { state, setState };
}
```

## Performance and SEO
- Use appropriate Next.js metadata API for SEO
- Implement proper Open Graph and Twitter Card meta tags
- Use Next.js built-in optimizations (Image, Link, etc.)
- Consider implementing Progressive Web App features

## Security
- Validate all user inputs
- Use environment variables for sensitive data
- Implement proper authentication and authorization
- Follow OWASP security guidelines

## Testing
- Write unit tests for utilities and hooks
- Use React Testing Library for component tests
- Consider E2E tests with Playwright or Cypress
- Test accessibility with automated tools

Remember: Always prioritize user experience, maintainability, and performance in your code decisions.
